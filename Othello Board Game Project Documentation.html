<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello Game Project Documentation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
        }
        header {
            background: #333;
            color: #fff;
            padding-top: 30px;
            min-height: 70px;
            border-bottom: #77b300 3px solid;
        }
        header h1 {
            text-align: center;
            text-transform: uppercase;
            margin: 0;
            font-size: 24px;
        }
        section {
            padding: 20px;
            background: #fff;
            margin-bottom: 20px;
        }
        h2, h3 {
            color: #333;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            overflow-x: auto;
        }
        .screenshot {
            display: block;
            margin: 10px 0;
            max-width: 100%;
        }
        img {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
    </style>
</head>
<body>
    
    <header>
        <h1>Othello</h1>
    </header>
    <div class="container">
        <section>
            <img src="D:\Uni\semester 6\AI\Project(AI(Othello))\Othelloo.jpg" alt="Main Menu">
            <h2>Project Overview</h2>
            <p>This project is an implementation of the Othello (also known as Reversi) game using Python's <code>tkinter</code> library for the graphical user interface (GUI) and <code>pygame</code> for background music. The game includes features for single-player mode against an AI, two-player mode, options to toggle sound, and instructions on how to play the game.</p>
        </section>

        <section>
            <h2>Step-by-Step Breakdown</h2>
            <h3>1. Initialization and Setup</h3>
            <h4>Libraries Imported</h4>
            <ul>
                <li><strong>tkinter</strong>: For creating the GUI.</li>
                <li><strong>messagebox</strong>: For displaying dialog boxes.</li>
                <li><strong>PIL (Pillow)</strong>: For image handling and manipulation.</li>
                <li><strong>copy</strong>: For copying objects.</li>
                <li><strong>math</strong>: For mathematical operations.</li>
                <li><strong>pygame</strong>: For playing background music.</li>
            </ul>
            <h4>Class Definition</h4>
            <ul>
                <li><strong>OthelloGame</strong>: The main class that contains all methods and attributes necessary to run the game.</li>
            </ul>
            <h4>Root Window Setup</h4>
            <ul>
                <li><strong>self.root</strong>: Initializes the main window of the application and sets the title to "Othello".</li>
            </ul>
            <h4>Board Initialization</h4>
            <ul>
                <li><strong>self.board</strong>: An 8x8 list of lists that represents the game board, initialized with empty strings.</li>
            </ul>
            <h4>Current Player</h4>
            <ul>
                <li><strong>self.current_player</strong>: A string that keeps track of whose turn it is, starting with 'black'.</li>
            </ul>
            <h4>Splash Screen</h4>
            <ul>
                <li><strong>self.show_splash_screen()</strong>: Displays the initial splash screen.</li>
            </ul>
            <h4>Pygame Mixer Initialization</h4>
            <ul>
                <li>Initializes pygame's mixer to handle background music.</li>
            </ul>
        </section>

        <section>
            <h3>2. Splash Screen and Main Menu</h3>
            <h4>Splash Screen</h4>
            <img src="D:\Uni\semester 6\AI\Project(AI(Othello))\1.jpg" alt="Splash Screen">
            <ul>
                <li><strong>show_splash_screen()</strong>: Displays an image as the splash screen and transitions to the main menu when clicked.</li>
            </ul>
            <h4>Main Menu</h4>
            <img src="D:\Uni\semester 6\AI\Project(AI(Othello))\2.jpg" alt="Main Menu">
            <ul>
                <li><strong>create_start_screen()</strong>: Displays the main menu with options for one player, two players, settings, how to play, and exit.</li>
            </ul>
        </section>

        <section>
            <h3>3. Options Mode</h3>
            <img src="D:\Uni\semester 6\AI\Project(AI(Othello))\5.jpg" alt="Options Screen">

            <h4>Sound Toggle</h4>
            <ul>
                <li><strong>options_mode()</strong>: Displays the options menu where the user can toggle the background music.</li>
                <li><strong>toggle_sound()</strong>: Toggles the music on and off by pausing and unpausing the pygame mixer.</li>
            </ul>
            <h4>Back Button</h4>
            <ul>
                <li>Returns to the main menu from the options screen.</li>
            </ul>
        </section>

        <section>
            <h3>4. How to Play Mode</h3>
            <h4>Instructions</h4>
            <ul>
                <img src="D:\Uni\semester 6\AI\Project(AI(Othello))\3.jpg" alt="How to Play">
                <li><strong>how_to_play_mode()</strong>: Displays detailed instructions on how to play the game.</li>
                <img src="D:\Uni\semester 6\AI\Project(AI(Othello))\4.jpg" alt="Game Rules">
                <li><strong>rules_mode()</strong>: Further explains the rules of Othello with text and images.</li>
            </ul>
        </section>

        <section>
            <h3>5. Color Choice Screen</h3>
            <img src="D:\Uni\semester 6\AI\Project(AI(Othello))\6.jpg" alt="Color Choice">

            <h4>Color Selection</h4>
            <ul>
                <li><strong>show_color_choice_screen()</strong>: Allows the user to choose their color (black or white) for single-player mode.</li>
            </ul>
        </section>

        <section>
            <h3>6. Game Initialization</h3>
            <img src="D:\Uni\semester 6\AI\Project(AI(Othello))\7.jpg" alt="Game Initialization">

            <h4>Board Setup</h4>
            <ul>
                <li><strong>start_game(color)</strong>: Sets up the initial positions of the pieces on the board.</li>
            </ul>
            <h4>Game Screen</h4>
            <ul>
                <li><strong>show_game_screen()</strong>: Displays the game board and updates the status labels to show the current player's turn.</li>
            </ul>
        </section>

        <section>
            <h3>7. Exit Mode</h3>
            <img src="D:\Uni\semester 6\AI\Project(AI(Othello))\9.jpg" alt="Exit Confirmation">

            <h4>Confirmation Dialog</h4>
            <ul>
                <li><strong>exit_mode()</strong>: Asks the user for confirmation before exiting the game.</li>
            </ul>
        </section>

        <section>
            <h2>Explanation of the Main Algorithm (Minimax Algorithm)</h2>
            <h3>Overview</h3>
            <p>The Minimax algorithm is a recursive algorithm used for decision-making and game theory. It provides an optimal move for the player assuming that the opponent also plays optimally. The algorithm is commonly used in two-player zero-sum games like Othello, Chess, and Tic-Tac-Toe.</p>
            <h3>Minimax Algorithm Steps</h3>
            <ol>
                <li><strong>Generate the Game Tree</strong>: The game tree represents all possible moves from the current state of the game.</li>
                <li><strong>Assign Scores to Terminal States</strong>: Evaluate the terminal states (end of the game) and assign scores. For Othello, this might be the difference in the number of pieces between the two players.</li>
                <li><strong>Propagate Scores Up the Tree</strong>: Use the scores of the terminal states to evaluate the non-terminal states. The scores are propagated up the tree to determine the best move.</li>
                <li><strong>Maximizing and Minimizing</strong>: The algorithm alternates between maximizing and minimizing. The maximizing player tries to get the highest score, while the minimizing player tries to get the lowest score.</li>
            </ol>
            <pre><code>def minimax(board, depth, is_maximizing):
    if depth == 0 or game_over(board):
        return evaluate_board(board)
    
    if is_maximizing:
        max_eval = float('-inf')
        for move in get_possible_moves(board, 'black'):
            new_board = make_move(board, move, 'black')
            eval = minimax(new_board, depth - 1, False)
            max_eval = max(max_eval, eval)
        return max_eval
    else:
        min_eval = float('inf')
        for move in get_possible_moves(board, 'white'):
            new_board = make_move(board, move, 'white')
            eval = minimax(new_board, depth - 1, True)
            min_eval = min(min_eval, eval)
        return min_eval
</code></pre>
        </section>

        <section>
            <h3>Alpha-Beta Pruning</h3>
            <p>To optimize the performance of the Minimax algorithm, Alpha-Beta pruning is used. It reduces the number of nodes evaluated in the search tree by pruning branches that cannot affect the final decision.</p>
            <pre><code>function minimax_alpha_beta(board, depth, alpha, beta, is_maximizing) {
if (depth == 0 || game_over(board)) {
return evaluate_board(board);
}
if (is_maximizing) {
let max_eval = -Infinity;
for (let move of get_possible_moves(board, 'black')) {
let new_board = make_move(board, move, 'black');
let eval = minimax_alpha_beta(new_board, depth - 1, alpha, beta, false);
max_eval = Math.max(max_eval, eval);
alpha = Math.max(alpha, eval);
if (beta <= alpha) {
break;
}
}
return max_eval;
} else {
let min_eval = Infinity;
for (let move of get_possible_moves(board, 'white')) {
let new_board = make_move(board, move, 'white');
let eval = minimax_alpha_beta(new_board, depth - 1, alpha, beta, true);
min_eval = Math.min(min_eval, eval);
beta = Math.min(beta, eval);
if (beta <= alpha) {
break;
}
}
return min_eval;
}
}</code></pre>
        </section>

        <section>
            <h3>Functions Used in Minimax</h3>
            <ul>
                <li><strong>evaluate_board(board)</strong>: Evaluates the board and returns a score based on the current state.</li>
                <li><strong>get_possible_moves(board, player)</strong>: Returns a list of all possible moves for the given player.</li>
                <li><strong>make_move(board, move, player)</strong>: Makes the move on the board and returns the new board state.</li>
                <li><strong>game_over(board)</strong>: Checks if the game is over.</li>
            </ul>
        </section>

        <section>
            <h3>Rules of Othello</h3>
            <ol>
                <li><strong>Starting Position</strong>: The game starts with four pieces placed in the center of the board in a specific pattern: two black and two white pieces diagonal to each other.</li>
                <li><strong>Objective</strong>: The goal is to have the majority of pieces turned to display your color by the end of the game.</li>
                <li><strong>Making Moves</strong>: Players take turns placing a piece of their color on the board. A valid move must sandwich one or more of the opponent's pieces between the placed piece and another piece of the same color.</li>
                <li><strong>Flipping Pieces</strong>: All sandwiched opponent pieces are flipped to the current player's color.</li>
                <li><strong>Passing Turns</strong>: If a player cannot make a valid move, they pass their turn.</li>
                <li><strong>End of Game</strong>: The game ends when neither player can make a valid move. The player with the most pieces of their color on the board wins.</li>
            </ol>
        </section>

        <section>
            <h3>Conclusion</h3>
            <p>This Othello game project provides a comprehensive implementation of the classic board game with a graphical interface and background music. The game includes both single-player and two-player modes, as well as detailed instructions and game rules for new players. The use of tkinter for the GUI and pygame for music integration demonstrates a blend of different Python libraries to create an engaging user experience.</p>
        </section>

        <footer>
            <p>Anna Nami<br>StudentNumber:40032143</p>
        </footer>
    </div>
</body>
</html>
